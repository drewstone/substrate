# Ethereum ←→ Edgeware Bridge

We want to build a bridge that enables the following functionality:

1. Lockdrop mechanism for ERC20 minting of Edgeware tokens
2. Bridge contract for depositing EdgewareERC20
3. Ethereum to Edgeware bridge for converting deposited EdgewareERC20 for Edgeware tokens and vice versa.

The bridged blockchain allegedly needs to be Ethereum-compatible, but what does this mean?

1. An interface(s) for ERC20 like token balance state.
2. Account based architectures.

Current problems:

1. Implementations expect Proof of Authority consensus.
    - Can we use Proof of Stake if we implement a sufficient relaying system? I suppose we should since Proof of Stake is similar to PoA in that validators are known but perhaps have stake weighted voting messes with relaying.

Examples:

1. [PoA bridge](https://github.com/poanetwork/poa-bridge)
2. [PoA bridge contracts](https://github.com/poanetwork/poa-bridge-contracts)
3. [Parity bridge](https://github.com/paritytech/parity-bridge)
4. [Cosmos Peg Zone](https://github.com/cosmos/peggy)

**BUILD BRIDGE USING THE COUNCIL AND/OR DEMOCRACY**

# Deposit

---

1. User deposits **EdgewareERC20** into **EdgewareBridge** contract, emitting a **Deposit** event.
    - event **Deposit(sender, value)**
    - generates transaction hash **H**
2. For each **Deposit** event, the relay authorities will trigger the function **Edgeware.Deposit** on the Edgeware chain.
    - function **Deposit(sender, value, transactionHash)**
    - once there are **Edgeware.requiredSignatures** who have deposited on behalf of **sender** with the same arguments **value** and **transactionHash**
    - *Note: Since we are running a Proof of Stake chain, I propose that instead of of using **Edgeware.requiredSignatures** we ensure that **Edgeware.requiredStake** has been allocated towards (signed) this decision. Now, what's weird is this entire sequence seems highly abused by the wrong participants, so perhaps that is where the burden is on us to do it as a trusted party, i.e. with stake that we initially seed to ourselves and our investors, et al. I guess this is why we say at least 51% is honest.*

Substrate specific

- Handle things like Council Origin, but modify the origin to care for stake instead of approval count.
- Calls for deposits are represented as a proposal to increase balance using the call balance extrinsic.

# Withdraw

---

1. User triggers **Withdraw** function on Edgeware, emitting a **Withdraw** event.
    - event **Withdraw(recipient, value, homeGasPrice)**
    - check **balance ≥ value**
    - gives back **transactionHash**
2. For each **Withdraw** event on Edgeware, the bridge authorities (relayers) create messages containing **recipient**, **value**, ****and **transactionHash** of the transaction referenced by the event.
    - message **M(recipient, value, transactionHash)**
    - `pub WithdrawMessage get(transaction_hash): Option<(T::AccountId, T::Balance, T::Hash)>`
3. The bridge authority signs the message, generating a **signature** and submits it on **Edgeware**. Once the bridge authorities making up **Edgeware.requiredStake** have signed a **Withdraw** event, we emit another event, **CollectedSignatures**.
    - `pub SignedWithdrawals get(transaction_hash): map T::Hash => Vec<::primitives::ed25519::Signature>`
    - Each time someone signs and adds a new message, we calculate the current stake signing this withdrawal. If it is enough, we throw the event below.
    - event **CollectedSignatures(authorityThatSubmittedLastSignature, messageHash)**
4. Any bridge authority calls the function **EdgewareBridge.Withdraw** to initiate a withdraw on **recipient**'s balance.
    - function **Withdraw(vs, rs, ss, message)**
    - The function checks that enough authorities in its authority list have signed and finally transfers value ether (minus the relay gas costs) to recipient.
    - **Can the user themselves hit this function? *As long as it's safe.***
        - The user can grab all the signatures from Edgeware's SignedWithdrawals mapping.
        - Parse the signatures for the vs, rs, ss

# Tasks

---

1. Need to decide whether we will run full Ethereum node alongside Edgeware or if this will be a light-ish node/simple web3 contract monitorer
    - [ ]  Build a web3 poller for watching lockdrop contract events (light implementation)
    - [ ]  Hook full ethereum node into Edgeware node to run side by side and use web3 poller
2. Build bridge contracts
    - [x]  Lock drop contract for locking ETH (and earning ERC20?)
    - [x]  Add tests for lock drop contract for locking ETH (and earning ERC20
    - [ ]  Bridge authority contract for taking signatures are minting ERC20
    - [ ]  Build functionality for updating bridge authorities
        - Only existing authorites can add (hopefully 2/3 stake)
3. Build Edgeware token minting process
    - [x]  Decide of minting curve based on timelocked length
4. Economic incentives for making sure that deposits and withdraws are signed correctly
